<?xml version="1.0" encoding="UTF-8"?>
<protocol name="wayland"
	  xmlns="http://wayland.freedesktop.org/protocol"
	  xmlns:client="http://wayland.freedesktop.org/protocol/client"
	  xmlns:server="http://wayland.freedesktop.org/protocol/server">

  <copyright>
    Copyright © 2008-2011 Kristian Høgsberg
    Copyright © 2010-2011 Intel Corporation

    Permission to use, copy, modify, distribute, and sell this
    software and its documentation for any purpose is hereby granted
    without fee, provided that\n the above copyright notice appear in
    all copies and that both that copyright notice and this permission
    notice appear in supporting documentation, and that the name of
    the copyright holders not be used in advertising or publicity
    pertaining to distribution of the software without specific,
    written prior permission.  The copyright holders make no
    representations about the suitability of this software for any
    purpose.  It is provided "as is" without express or implied
    warranty.

    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
    THIS SOFTWARE.
  </copyright>

  <!-- The core global object. This is a special singleton object.
       It is used for internal wayland protocol features. -->
  <interface name="wl_display" version="1" client:custom="yes">
    <!-- This is a special request used to send initial out-of-band
         data (such as the credentials of the client). Clients must
         send it immediately after connecting to the compositor, and
         compositors must read it immediately after accepting the
         connection. The compositor responds to this request by
         emitting global events. -->
    <request name="hello" />

    <request name="bind">
      <arg name="name" type="uint"/>
      <arg name="interface" type="string"/>
      <arg name="version" type="uint"/>
      <arg name="id" type="new_id" interface="wl_object"/>
    </request>

    <!-- sync is an just an echo, which will reply with a key event.
         Since requests are handled in-order, this can be used as a
         barrier to ensure all previous requests have been handled.
         The key argument can be used to correlate between multiple
         sync invocations. -->
    <request name="sync">
      <arg name="callback" type="new_id" interface="wl_callback"/>
    </request>

    <!-- A fatal error has occurred. -->
    <event name="error">
      <arg name="object_id" type="object" interface="wl_object"/>
      <arg name="code" type="uint"/>
      <arg name="message" type="string"/>
    </event>

    <enum name="error">
      <entry name="invalid_object" value="0"/>
      <entry name="invalid_method" value="1"/>
      <entry name="no_memory" value="2"/>
    </enum>

    <!-- Notify the client of global objects. These are objects that
         are created by the server. Globals are published on the
         initial client connection sequence, upon device hotplugs,
         device disconnects, reconfiguration or other events.  The
         server will always announce an object before the object sends
         out events. -->
    <event name="global">
      <arg name="name" type="uint" interface="wl_object"/>
      <arg name="interface" type="string"/>
      <arg name="version" type="uint"/>
    </event>

    <!-- Notify the client of removed global objects. -->
    <event name="global_remove">
      <arg name="id" type="uint" />
    </event>

  </interface>

  <interface name="wl_callback" version="1">
    <event name="done">
      <arg name="time" type="uint"/>
    </event>
  </interface>

  <!-- A compositor. This object is a global.  The compositor is in
       charge of combining the contents of multiple surfaces into one
       displayable output. -->
  <interface name="wl_compositor" version="1">
    <!-- Factory request for a surface objects. A surface is akin to a
         window. -->
    <request name="create_surface">
      <arg name="id" type="new_id" interface="wl_surface"/>
    </request>
  </interface>

  <!-- Shared memory support -->
  <interface name="wl_shm" version="1">
    <enum name="error">
      <entry name="invalid_format" value="0"/>
      <entry name="invalid_stride" value="1"/>
      <entry name="invalid_fd" value="2"/>
    </enum>

    <enum name="format">
      <entry name="argb32" value="0"/>
      <entry name="premultiplied_argb32" value="1"/>
      <entry name="xrgb32" value="2"/>
    </enum>

    <!-- Transfer a shm buffer to the server.  The allocated buffer
         would include at least stride * height bytes starting at the
         beginning of fd.  The file descriptor is transferred over the
         socket using AF_UNIX magical features. width, height, stride
         and format describe the respective properties of the pixel
         data contained in the buffer. -->
    <request name="create_buffer">
      <arg name="id" type="new_id" interface="wl_buffer"/>
      <arg name="fd" type="fd"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
      <arg name="stride" type="uint"/>
      <arg name="format" type="uint"/>
    </request>

    <event name="format">
      <arg name="format" type="uint"/>
    </event>
  </interface>


  <!-- A pixel buffer. Created using the drm, shm or similar objects.
       It has a size, visual and contents, but not a location on the
       screen. -->
  <interface name="wl_buffer" version="1">
    <!-- Notify the server that the specified area of the buffers
         contents have changed.  To describe a more complicated area
         of damage, break down the region into rectangles and use this
         request several times.
    -->
    <request name="damage">
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>

    <!-- Destroy a buffer.  This will invalidate the object id. -->
    <request name="destroy" type="destructor"/>

    <!-- Sent when an attached buffer is no longer used by the compositor. -->
    <event name="release"/>
  </interface>

  <interface name="wl_shell" version="1">
    <enum name="resize_operation">
      <entry name="none" value="0"/>
      <entry name="top" value="1"/>
      <entry name="bottom" value="2"/>
      <entry name="left" value="4"/>
      <entry name="top_left" value="5"/>
      <entry name="bottom_left" value="6"/>
      <entry name="right" value="8"/>
      <entry name="top_right" value="9"/>
      <entry name="bottom_right" value="10"/>
    </enum>

    <request name="start_move_resize">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="input_device" type="object" interface="wl_input_device"/>
      <arg name="time" type="uint"/>
      <arg name="resize_edges" type="uint"/>
    </request>

    <enum name="restack_operation">
      <entry name="top" value="0"/>
      <entry name="bottom" value="1"/>
      <entry name="above" value="2"/>
      <entry name="below" value="3"/>
    </enum>

    <request name="restack">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="operation" type="uint"/>
      <arg name="sibling" type="object" interface="wl_surface"/>
    </request>

    <enum name="gravity">
      <entry name="static" value="0"/>
      <entry name="top_left" value="1"/>
      <entry name="top_right" value="2"/>
      <entry name="bottom_right" value="3"/>
      <entry name="bottom_left" value="4"/>
      <entry name="center" value="5"/>
    </enum>

    <!-- Request a programmatical resize of a surface. The surface
         will be marked "resizing" by the compositor, and a
	 configure_notify event will be emitted with the new size
	 (after applying any server-side policy). See the
	 documentation of wl_surface.attach for the complete description
	 of resizing. x and y can be both -1, to indicate that
	 the new position should be obtained according to the specified
	 gravity, which represents a reference point that won't
	 move on screen; gravity is ignored if x and y are not negative;
	 any other negative value will cause an error.
    -->
    <request name="configure">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
      <arg name="gravity" type="uint"/>
    </request>

    <request name="create_drag">
      <arg name="id" type="new_id" interface="wl_drag"/>
    </request>

    <request name="create_selection">
      <arg name="id" type="new_id" interface="wl_selection"/>
    </request>

    <!-- Make the surface visible as a toplevel window. The timestamp
         should be derived from the event that triggered this mapping,
         and will be used for stacking and applying focus policies.
         If this is the first surface of the application, it should be
         taken from the DESKTOP_STARTUP_ID environment variable (if
	 present).
	 Parent indicates that this surface is transient (it can be a
	 dialog box or a popup menu); the compositor shall hide the
	 surface when the parent is hidden and shall keep the
         transient surface above the parent at all times.
	 wm_desktop indicates the desired workspace, if the compositor
	 supports the concept, and should be taken from DESKTOP_STARTUP_ID.
	 Compositors are free to ignore it at all times. -->
    <request name="map">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="parent" type="object" interface="wl_surface"/>
      <arg name="flags" type="uint"/>
      <arg name="timestamp" type="uint"/>
      <arg name="wm_desktop" type="uint"/>
    </request>

    <!-- These flags can be passed to map and affect the interpretation
         of its parameters -->
    <enum name="map_flags">
      <!-- The position in the latest configure request was specified by
	   the user (for example using a command line switch) and the
	   compositor should honor it -->
      <entry name="user_position" value="1"/>

      <!-- Same as user_position, but for size -->
      <entry name="user_size" value="2"/>

      <!-- The position in map is in the parent's coordinate space, and
           the surface should be moved when the parent moves. This can be
           used for popup menus.
           Parent must be valid or an error is emitted. -->
      <entry name="keep_parent_position" value="4"/>

      <!-- This window is modal for its parent: while the window is active,
           the parent is prevented from accepting pointer and keyboard
	   focus. Events are not redirected though: if you need that, use
	   a client-side grab and don't set this flag.
	   Compositors can for example use this hint to position the window
	   attached to the parent's title bar, or to dim the content of the
           parent surface.
           An error is emitted if this flag is set and parent is not valid. -->
      <entry name="modal_dialog" value="8"/>

      <!-- This window is part of a strut. Struts are four stripes of spaces
           along the edge of each output that are reserved for special
	   windows and are not part of the workarea (the space the compositor
	   uses to move and resize windows). They are computed by unioning
	   the extents of windows mapped with the affect_struts flag on each edge.
	   By setting this flag, you're asking that other windows be prevented
	   from overlap and the compositor reserve space for it at all times.
	   Position must be valid and must be along the edge of an output.
	   Results are undefined if the position does not touch an edge
	   (compositors are free to emit an error or to ignore the flag). If
	   the surface touches more than one edge, it affects the struts of
	   the longest.
	   Parent must be 0, or an error will be emitted. For this reason,
           this flag is mutually exclusive with keep_parent_position and
           modal_dialog. -->
      <entry name="affect_struts" value="16"/>

      <!-- This window accepts keyboard focus. Differently from X11, there are
	   only input focus mode: either you accept focus (in a mode similar to
	   PassiveInput), or you don't. This difference is because there are no
	   child windows in wayland and you cannot explicitly set the input focus
	   around.
	   Since this flag cannot be modified after the window is mapped, clients
	   that wish to change this should unmap and remap the window. -->
      <entry name="accept_focus" value="32"/>
    </enum>

    <!-- Unmaps (withdraws) the surface. A withdrawn surface is not
         visible (compositors must not show it) and cannot be interacted
	 with. Other than that, compositors must still process updates
	 and keep a backing store for it, as the surface may be remapped
	 at any time. -->
    <request name="unmap">
      <arg name="surface" type="object" interface="wl_surface"/>
    </request>

    <!-- Requests that the compositor activates a window. The exact results
         are implementation-defined, but will often include restacking to
	 the top and acquiring pointer and keyboard focus.
         Timestamp should be derived from the event that triggered this call,
         and will be used for policy decisions (for example, a compositor
         may decide that activate requests older than a certain point will
         result in wm_state demands_attention) -->
    <request name="activate">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="timestamp" type="uint"/>
    </request>

    <!-- The configure_notify event communicates to the client the new
	 size of the surface, after resizing performed by the compositor
	 or as a result of a configure request. The position coordinates
	 are allowed to be 0,0 if the compositor is unable to do otherwise
	 (for example because it is transforming the window in 3D space),
	 but should reflect the delta between surface coords and root coords in
	 pointer events.
	 The client is free to dismiss all but the last configure_notify
	 event it received, and should do so if it has emitted a configure
	 request at a later time. See the documentation of wl_surface.attach
	 for the full documentation of the resize process. -->
    <event name="configure_notify">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="serial" type="uint"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </event>

    <!-- The set_wm_size_hint request provides the compositor with a set
         of values that are used to constrain the size of the window.
	 Compositors must respect the min size and max size hints, when set,
	 as otherwise clients may be unable to prepare an appropriate buffer.
	 The other hints may be ignore in particular situations (such
	 as when the window is maximized).
	 If any hints are to be set, this request should be emitted at least
	 once before mapping the window, as often the compositor will
	 reconfigure the window to its own likes rigth after mapping.
	 All arguments can be -1, to indicate that a particular hint is
	 not relevant. Other negative values will cause an error.
         Multiple configure_hint requests in succession override each other
         for all hints, including those specified as -1. Toolkits that
	 allow setting each one independently should cache the value and
	 emit a full request every time.
         The exact constraint, for each dimension, is that it must not be
         larger than max_size (if specified), it must not be smaller than
	 min_size (if specified), and must be equal to
	 base_size + n * inc_size, for some integer value of n (if both
	 base_size and inc_size are specified). If aspect ratio is
	 specified, the ratio of width to height must be equal to that
	 given (up to a reasonable precision) -->
    <request name="set_wm_size_hint">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="max_width" type="int"/>
      <arg name="max_height" type="int"/>
      <arg name="min_width" type="int"/>
      <arg name="min_height" type="int"/>
      <arg name="base_width" type="int"/>
      <arg name="base_height" type="int"/>
      <arg name="inc_width" type="int"/>
      <arg name="inc_height" type="int"/>
      <arg name="aspect_ratio" type="double"/>
    </request>

    <!-- This event is sent when the compositor wishes that the client
	 destroyed the surface, for example because the user clicked an
         X button. This event may be followed immediately by a ping
         event on wl_display and then possibly termination (but the client
         can prevent this by responding to ping).
         The compositor should not unmap the window or close the connection
         just because a delete event is not acted upon timely: the client
         is allowed to ask for confirmation or to show a window indicating
         that further progress is needed before cleanly closing. -->
    <event name="delete">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="timestamp" type="uint"/>
    </event>

    <!-- This is the title of the surface. It should be a localized UTF-8 string
         that can show in the decorations and in application or window switchers.
         For futher information on the content of this property, see the
         Human Interface Guidelines for your target environment.
         Compositors cannot change the value of wm_name, and should accept any
         value, although are free to show different strings in their UI -->
    <request name="set_wm_name">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="value" type="string"/>
    </request>

    <!-- This is an identifier for the application holding this surface.
	 For the first part, it must hold that concatenating is value with
	 the exact string ".desktop" results in a valid desktop file for the
	 application, visible at least to the client. The second part is the
	 instance part, and can be used to distinguish different instances of
	 the same application. It is not guaranteed that either class or
	 instance are valid UTF-8 strings.
	 Different clients (processes) with the same value of class and instance
	 are considered to be in the same instance, and should be handled togheter
	 if the compositor does application matching or window grouping. -->
    <request name="set_wm_class">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="class" type="string"/>
      <arg name="instance" type="string"/>
    </request>

    <enum name="wm_window_type">
      <entry name="normal" value="0"/>
      <entry name="desktop" value="1"/>
      <entry name="dock" value="2"/>
      <entry name="toolbar" value="3"/>
      <entry name="floating_menu" value="4"/>
      <entry name="utility" value="5"/>
      <entry name="splash" value="6"/>
      <entry name="dialog" value="7"/>
      <entry name="dropdown_menu" value="8"/>
      <entry name="popup_menu" value="9"/>
      <entry name="tooltip" value="10"/>
      <entry name="notification" value="11"/>
      <entry name="combo" value="12"/>
      <!-- XXX: is this needed? Or rather it should be a special cursor/
           or a surface managed by the compositor? -->
      <entry name="dnd" value="13"/>
    </enum>

    <!-- This specifies the type of this surface. The compositor may use this
	 hint to apply different policies or decorations, although the exact
         effects are implementation-defined. -->
    <request name="set_wm_window_type">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="type" type="uint"/>
    </request>

    <enum name="wm_state">
      <entry name="normal" value="0" />
      <entry name="iconic" value="1" />
      <entry name="withdrawn" value="2" />
      <entry name="maximized_horizontally" value="4" />
      <entry name="maximized_vertically" value="16" />
      <entry name="fullscreen" value="32" />
      <entry name="above" value="64" />
      <entry name="sticky" value="128" />
      <entry name="demands_attention" value="256" />
    </enum>

    <!-- This is the state of the surface. Values are taken from the wm_state enum.
         Normal is the absence of any other state, and indicates that the surface
	 is mapped normally, can be resized and can be focused.
	 Iconic indicates that the compositor is not mapping the surface normally,
	 and the surface won't receive input or focus; other than that, iconic is
	 equal to normal (so the client should continue emitting updates and animations,
	 as well as processing syntethic events, since the compositor may be showing
	 a thumbnail of the window or other form of preview). The other flags
	 indicates how the window should be shown when the iconic flag is cleared.
	 Withdrawn indicates that the window exists but the client wishes it to be
	 hidden. The compositor must not map it or emit any input device events on it,
	 but it must continue processing configures and updates, and be prepared to
	 map it again at any time. The other flags indicates how the window should
	 act when the window is mapped again. This flag cannot be set or cleared
	 using set_wm_state, use map/unmap methods instead.
	 Maximized_horizontally and maximized_vertically indicate that the surface
	 is grown to fit all available space on the screen in either direction.
	 Configure requests for the maximized direction must be ignored, although the
	 compositor can cache them and reuse them when the flag is cleared.
	 Fullscreen indicates that the surface is fullscreen, that is its size is
	 the size of one entire output, ignoring any UI element of the compositor that
	 would normally constrain surface size. This flag can be set on a withdrawn
	 or iconic window, indicating that upon state change the window should be
	 (or will be, if the flag is set by the compositor) fullscreened.
	 Above indicates a surface which should be stacked above all other surfaces
	 that don't have the above flags set. The compositor is free to ignore this
	 bit and stack all surfaces equally, but if doing so it should clear the flag
	 by emitting a wm_state_notify.
	 Sticky indicates that the surface should be shown on all virtual desktops.
	 If the compositor does not support the concept, setting or clearing this bit
	 will have no effect (and the compositor is not required to clear it).
	 Demands_attention indicates that the surface wishes to receive attention
	 (that is, input focus), for whatever reason. The compositor can set it if
	 it prevents other programmatical attempts to capture focus, or if it delays
	 mapping. The compositor will clear it when it feels the user has acknowledged
	 the request (for example, by giving focus to the surface or raising it to the
	 top of the stack) -->
    <request name="set_wm_state">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="value" type="uint"/>
      <arg name="change_mask" type="uint"/>
    </request>
    <event name="wm_state_changed">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="value" type="uint"/>
      <arg name="change_mask" type="uint"/>
    </event>
  </interface>

  <interface name="wl_selection" version="1">
    <!-- Add an offered mime type.  Can be called several times to
         offer multiple types, but must be called before 'activate'. -->
    <request name="offer">
      <arg name="type" type="string"/>
    </request>

    <!-- Can the selection be activated for multiple devices? -->
    <request name="activate">
      <arg name="input_device" type="object" interface="wl_input_device"/>
      <arg name="time" type="uint"/>
    </request>

    <!-- Destroy the selection. -->
    <request name="destroy" type="destructor"/>

    <!-- Another client pasted the selection, send the mime-type over
         the passed fd. -->
    <event name="send">
      <arg name="mime_type" type="string"/>
      <arg name="fd" type="fd"/>
    </event>

    <!-- Another selection became active. -->
    <event name="cancelled"/>
  </interface>

  <interface name="wl_selection_offer" version="1">
    <!-- Called to receive the selection data as the specified type.
         Sends the pipe fd to the compositor, which forwards it to the
         source in the 'send' event -->
    <request name="receive">
      <arg name="mime_type" type="string"/>
      <arg name="fd" type="fd"/>
    </request>

    <!-- Sent before the keyboard_focus event to announce the types
         offered.  One event per offered mime type.  A mime type of
         NULL means the selection offer is going away.  -->
    <event name="offer">
      <arg name="type" type="string"/>
    </event>

    <event name="keyboard_focus">
      <arg name="input_device" type="object" interface="wl_input_device"/>
    </event>
  </interface>

  <interface name="wl_drag" version="1">
    <!-- Add an offered mime type.  Can be called several times to
         offer multiple types, but must be called before 'activate'. -->
    <request name="offer">
      <arg name="type" type="string"/>
    </request>

    <request name="activate">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="input_device" type="object" interface="wl_input_device"/>
      <arg name="time" type="uint"/>
    </request>

    <!-- Destroy the drag and cancel the session. -->
    <request name="destroy" type="destructor"/>

    <!-- Sent when a target accepts pointer_focus or motion events.
         If a target does not accept any of the offered types, type is
         NULL -->
    <event name="target">
      <arg name="mime_type" type="string"/>
    </event>

    <!-- Sent when the drag is finished.  The final mime type is that
         of the last target event.  If that was NULL, no drag target
         was valid when the drag finished, fd is undefined and the
         source should not send data.  The event is also sent in case
         a drag source tries to activate a drag after the grab was
         released, in which case mime_type will also be NULL. -->
    <event name="finish">
      <arg name="fd" type="fd"/>
    </event>

    <event name="reject"/>
  </interface>


  <interface name="wl_drag_offer" version="1">
    <!-- Call to accept the offer of the given type -->
    <request name="accept">
      <arg name="time" type="uint"/>
      <arg name="type" type="string"/>
    </request>

    <!-- Called to initiate the drag finish sequence.  Sends the pipe
         fd to the compositor, which forwards it to the source in the
         'finish' event -->
    <request name="receive">
      <arg name="fd" type="fd"/>
    </request>

    <!-- Called to reject a drop  -->
    <request name="reject"/>

    <!-- Sent before the pointer_focus event to announce the types
         offered.  One event per offered mime type. -->
    <event name="offer">
      <arg name="type" type="string"/>
    </event>

    <!-- Similar to device::pointer_focus.  Sent to potential target
         surfaces to offer drag data.  If the device leaves the
         window, the drag stops or the originator cancels the drag,
         this event is sent with the NULL surface, at which point the
         drag object may no longer be valid. -->
    <event name="pointer_focus">
      <arg name="time" type="uint"/>
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="surface_x" type="int"/>
      <arg name="surface_y" type="int"/>
    </event>

    <!-- Similar to device::motion.  Sent to potential target surfaces
         as the drag pointer moves around in the surface. -->
    <event name="motion">
      <arg name="time" type="uint"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="surface_x" type="int"/>
      <arg name="surface_y" type="int"/>
    </event>

    <!-- Sent to indicate that the drag is finishing.  The last
         motion/pointer_focus event gives the location of the drop.
         Target must respond with the 'receive' request, which sends
         an fd to the source for writing the drag data. -->
    <event name="drop"/>
  </interface>


  <!-- A surface. This is an image that is displayed on the screen.
       It has a location, size and pixel contents. Similar to a window. -->
  <interface name="wl_surface" version="1">
    <!-- Deletes the surface and invalidates its object id. -->
    <request name="destroy" type="destructor"/>

    <!-- Attach a buffer into this surface. The buffer becomes the
	 effective backing store of the surface, and any change to it
	 (if accompained by appropriate damage requests) will be visible
	 on screen. The buffer is always attached at the top left of the
	 surface.
         The configure_serial argument must be the serial of a received
         wl_shell.configure_notify event, if this attachment is a result
	 of resizing, and 0 otherwise.
         The buffer must be sized according to the size of the window, or
         results will be undefined. If configure_serial is non-zero, a
	 valid size (that compositor will honor without clipping or repeating
	 the buffer) is any size between the previous attached buffer size
	 and the size specified in that wl_shell.configure_notify event (inclusive).
	 When the size exactly matches that of the configure_notify, the
	 event and all its predecessors are considered handled and will no
	 longer be valid for the configure_serial arguments. Compositors
	 must not reuse serials twice for the same wl_surface, though different
	 wl_surface can have the same serial. Clients are expected to handle
	 configure_notify events as soon as possible by creating and attaching
	 a new buffer; the compositor may report clients failing to do so
	 to the user as "lagging" and, for example, offer to kill them.
	 If configure_serial is 0, on the other hand, the buffer must be
	 exactly the same size as the previous buffer (even if the window
	 has changed size in the meanwhile). If there is no previous buffer,
	 any size is valid (but it is possible that the compositor will ignore
	 this buffer and immediately emit a configure_notify after mapping). -->
    <request name="attach">
      <arg name="buffer" type="object" interface="wl_buffer"/>
      <arg name="configure_serial" type="uint"/>
    </request>

    <!-- After attaching a new buffer, this request is used to
         describe the regions where the new buffer is different from
         the previous buffer and needs to be repainted.  Coordinates
         are relative to the top left of the surface. -->
    <request name="damage">
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>

    <!-- Request notification when the next frame is displayed.
         Useful for throttling redrawing operations, and driving
         animations.  The notification will only be posted for one
         frame unless requested again. -->
    <request name="frame">
      <arg name="callback" type="new_id" interface="wl_callback"/>
    </request>
  </interface>

  <!-- A group of keyboards and pointer devices (mice, for
       example). This object is published as a global during start up,
       or when such a device is hot plugged.  A input_device group
       typically has a pointer and maintains a keyboard_focus and a
       pointer_focus.  -->
  <interface name="wl_input_device" version="1">
    <!-- Set the pointer's image.  This request only takes effect if
         the pointer focus for this device is one of the requesting
         clients surfaces.  -->
    <request name="attach">
      <arg name="time" type="uint"/>
      <arg name="buffer" type="object" interface="wl_buffer"/>
      <arg name="hotspot_x" type="int"/>
      <arg name="hotspot_y" type="int"/>
    </request>

    <!-- Notification of pointer location change.
         x,y are the absolute location on the screen.
         surface_[xy] are the location relative to the focused surface. -->
    <event name="motion">
      <arg name="time" type="uint"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="surface_x" type="int"/>
      <arg name="surface_y" type="int"/>
    </event>

    <!-- Mouse button click and release notifications.  The location
         of the click is given by the last motion or pointer_focus
         event. -->
    <event name="button">
      <arg name="time" type="uint"/>
      <arg name="button" type="uint"/>
      <arg name="state" type="uint"/>
    </event>

    <!-- Keyboard press. -->
    <event name="key">
      <arg name="time" type="uint"/>
      <arg name="key" type="uint"/>
      <arg name="state" type="uint"/>
    </event>

    <!-- Notification that this input device's pointer is focused on
         certain surface. When an input_device enters a surface, the
         pointer image is undefined and a client should respond to
         this event by setting an apropriate pointer image. -->
    <event name="pointer_focus">
      <arg name="time" type="uint"/>
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="surface_x" type="int"/>
      <arg name="surface_y" type="int"/>
    </event>

    <event name="keyboard_focus">
      <arg name="time" type="uint"/>
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="keys" type="array"/>
    </event>

    <event name="touch_down">
      <arg name="time" type="uint"/>
      <arg name="id" type="int" />
      <arg name="x" type="int" />
      <arg name="y" type="int" />
    </event>

    <event name="touch_up">
      <arg name="time" type="uint"/>
      <arg name="id" type="int" />
    </event>

    <event name="touch_motion">
      <arg name="time" type="uint"/>
      <arg name="id" type="int" />
      <arg name="x" type="int" />
      <arg name="y" type="int" />
    </event>

    <!-- Indicates the end of a contact point list. -->
    <event name="touch_frame"/>

    <!-- Sent if the compositor decides the touch stream is a global
         gesture. No further events are sent to the clients from that
         particular gesture. -->
    <event name="touch_cancel"/>
  </interface>


  <!-- An output describes part of the compositor geometry.  The
       compositor work in the 'compositor coordinate system' and an
       output corresponds to rectangular area in that space that is
       actually visible.  This typically corresponds to a monitor that
       displays part of the compositor space.  This object is
       published as global during start up, or when a screen is hot
       plugged.  -->
  <interface name="wl_output" version="1">

    <enum name="subpixel">
      <entry name="unknown" value="0"/>
      <entry name="none" value="1"/>
      <entry name="horizontal_rgb" value="2"/>
      <entry name="horizontal_bgr" value="3"/>
      <entry name="vertical_rgb" value="4"/>
      <entry name="vertical_bgr" value="5"/>
    </enum>

    <event name="geometry">
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="physical_width" type="int"/>
      <arg name="physical_height" type="int"/>
      <arg name="subpixel" type="int"/>
      <arg name="make" type="string"/>
      <arg name="model" type="string"/>
    </event>

    <!-- Values for the flags bitfield of the mode event. -->
    <enum name="mode">
      <entry name="current" value="0x1"/>
      <entry name="preferred" value="0x2"/>
    </enum>
      
    <event name="mode">
      <arg name="flags" type="uint"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
      <arg name="refresh" type="int"/>
    </event>
  </interface>

</protocol>
